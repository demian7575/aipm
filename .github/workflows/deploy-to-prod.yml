name: Deploy to Production

on:
  push:
    branches: [main]
  workflow_dispatch:
    inputs:
      force_deploy:
        description: 'Force deployment even if tests fail'
        required: false
        type: boolean
        default: false
      force_restart_session_pool:
        description: 'Force restart Session Pool even if unchanged'
        required: false
        type: boolean
        default: false

permissions:
  contents: write
  pull-requests: write

jobs:
  # Step 1: Deploy to Development and run Pre-Production tests
  deploy-and-test-dev:
    runs-on: ubuntu-latest
    outputs:
      gating-status: ${{ steps.gating.outputs.status }}
    environment: development
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3
        with:
          fetch-depth: 0
      
      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'
      
      - name: Install dependencies
        run: |
          npm install --legacy-peer-deps
          sudo apt-get update
          sudo apt-get install -y jq python3-yaml
      
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1
      
      - name: Load Development environment configuration
        run: |
          source scripts/utilities/load-env-config.sh dev
          echo "DEV_INSTANCE_ID=$INSTANCE_ID" >> $GITHUB_ENV
          echo "DEV_S3_BUCKET=$S3_BUCKET" >> $GITHUB_ENV
          echo "DEV_TERMINAL_URL=$TERMINAL_URL" >> $GITHUB_ENV
          echo "DEV_DYNAMODB_STORIES_TABLE=$DYNAMODB_STORIES_TABLE" >> $GITHUB_ENV
          echo "DEV_DYNAMODB_TESTS_TABLE=$DYNAMODB_TESTS_TABLE" >> $GITHUB_ENV
      
      - name: Setup SSH key
        env:
          SSH_PRIVATE_KEY: ${{ secrets.EC2_SSH_PRIVATE_KEY }}
        run: |
          mkdir -p ~/.ssh
          if echo "$SSH_PRIVATE_KEY" | base64 -d > ~/.ssh/id_rsa 2>/dev/null; then
            echo "âœ… Decoded base64 SSH key"
          else
            echo "ðŸ“ Using raw SSH key"
            printf '%s' "$SSH_PRIVATE_KEY" > ~/.ssh/id_rsa
          fi
          sed -i 's/\r$//' ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keygen -l -f ~/.ssh/id_rsa >/dev/null 2>&1 && echo "âœ… SSH key configured" || (echo "âŒ SSH key validation failed" && exit 1)
      
      - name: Start Development EC2 if stopped
        run: |
          echo "ðŸ” Checking Development EC2 status..."
          
          EC2_STATE=$(aws ec2 describe-instances \
            --instance-ids ${{ env.DEV_INSTANCE_ID }} \
            --region us-east-1 \
            --query 'Reservations[0].Instances[0].State.Name' \
            --output text)
          
          echo "Current state: $EC2_STATE"
          
          if [ "$EC2_STATE" = "stopped" ]; then
            echo "âš ï¸  EC2 is stopped, starting instance..."
            aws ec2 start-instances --instance-ids ${{ env.DEV_INSTANCE_ID }} --region us-east-1
            
            echo "â³ Waiting for EC2 to start..."
            aws ec2 wait instance-running --instance-ids ${{ env.DEV_INSTANCE_ID }} --region us-east-1
            
            echo "â³ Waiting for services to be ready (60 seconds)..."
            sleep 60
          elif [ "$EC2_STATE" = "running" ]; then
            echo "âœ… Development EC2 is already running"
          else
            echo "âš ï¸  Development EC2 state: $EC2_STATE"
          fi
          
          # Get current IP from AWS after EC2 is running
          echo "ðŸ” Getting current dev EC2 IP from AWS..."
          CURRENT_IP=$(aws ec2 describe-instances \
            --instance-ids ${{ env.DEV_INSTANCE_ID }} \
            --region us-east-1 \
            --query 'Reservations[0].Instances[0].PublicIpAddress' \
            --output text)
          
          if [ -z "$CURRENT_IP" ] || [ "$CURRENT_IP" = "None" ]; then
            echo "âŒ Failed to get IP from AWS"
            exit 1
          fi
          
          echo "DEV_EC2_IP=$CURRENT_IP" >> $GITHUB_ENV
          echo "DEV_API_BASE=http://$CURRENT_IP:4000" >> $GITHUB_ENV
          echo "DEV_SEMANTIC_API_BASE=http://$CURRENT_IP:8083" >> $GITHUB_ENV
          echo "âœ… Current IP: $CURRENT_IP"
          
          # Wait for API to respond
          MAX_WAIT=60
          ELAPSED=0
          while [ $ELAPSED -lt $MAX_WAIT ]; do
            if curl -s --max-time 5 "http://$CURRENT_IP:4000/health" > /dev/null 2>&1; then
              echo "âœ… Development API is ready"
              break
            fi
            sleep 5
            ELAPSED=$((ELAPSED + 5))
          done
          
          if [ $ELAPSED -ge $MAX_WAIT ]; then
            echo "âš ï¸  API not responding after ${MAX_WAIT}s, proceeding anyway..."
          fi
          
          # Add SSH host key
          SSH_ADDED=false
          for i in 1 2 3 4 5 6; do
            if ssh-keyscan -H $CURRENT_IP >> ~/.ssh/known_hosts 2>/dev/null; then
              echo "âœ… SSH host key added"
              SSH_ADDED=true
              break
            fi
            echo "â³ Waiting for SSH to be ready... (attempt $i/6)"
            sleep 5
          done
          
          if [ "$SSH_ADDED" = "false" ]; then
            echo "âš ï¸  Could not add SSH host key, will try with StrictHostKeyChecking=no"
          fi
      
      - name: Deploy to Development EC2
        env:
          GITHUB_TOKEN: ${{ secrets.AIPM_GITHUB_TOKEN }}
        run: |
          echo "ðŸš€ Deploying to Development EC2 for Pre-Production testing..."
          
          ./scripts/deploy-simple.sh dev
          echo "âœ… Backend deployed to Development EC2"
      
      - name: Deploy Lambda functions to Development
        run: |
          echo "âš¡ Deploying Lambda functions to Development..."
          ./scripts/deploy-lambda.sh dev skip-errors || echo "âš ï¸  Lambda deployment skipped (functions not created yet)"
          echo "âœ… Lambda step complete"
      
      - name: Deploy frontend to Development S3
        run: |
          echo "ðŸ“¦ Deploying frontend to Development S3..."
          
          # Create dev config
          cat > apps/frontend/public/config.js << EOF
          window.CONFIG = {
            API_BASE_URL: '${{ env.DEV_API_BASE }}',
            EC2_TERMINAL_URL: '${{ env.DEV_TERMINAL_URL }}',
            ENVIRONMENT: 'dev'
          };
          EOF
          
          aws s3 sync apps/frontend/public/ s3://${{ env.DEV_S3_BUCKET }} --delete --cache-control no-cache
          echo "âœ… Frontend deployed to Development S3"
      
      - name: Run Pre-Production Gating Tests
        id: gating
        env:
          GITHUB_TOKEN: ${{ secrets.AIPM_GITHUB_TOKEN }}
          TARGET_ENV: dev
          API_BASE: ${{ env.DEV_API_BASE }}
          SEMANTIC_API_BASE: ${{ env.DEV_SEMANTIC_API_BASE }}
          SSH_HOST: ${{ env.DEV_EC2_IP }}
          SKIP_GATING_TESTS_IN_CODE_GENERATION: true
        run: |
          echo "ðŸ§ª Running Pre-Production Gating Tests on Development Environment"
          echo "   Backend: $API_BASE"
          echo "   Database: Development DynamoDB"
          export PHASE="pre-production"
          
          # Wait for deployment to be ready
          sleep 10
          
          # Run Phase 1 (Security & Data Safety) and Phase 2 (E2E Workflow)
          if ./scripts/testing/run-structured-gating-tests.sh --phases "1,2"; then
            echo "âœ… Pre-Production tests passed - production deployment approved"
            echo "status=success" >> $GITHUB_OUTPUT
          else
            echo "âŒ Pre-Production tests failed"
            if [ "${{ github.event.inputs.force_deploy }}" = "true" ]; then
              echo "âš ï¸ Force deploy enabled - proceeding despite test failures"
              echo "status=success" >> $GITHUB_OUTPUT
            else
              echo "ðŸš« Blocking production deployment"
              echo "status=failure" >> $GITHUB_OUTPUT
              exit 1
            fi
          fi

  # Step 2: Deploy to Production and run Post-Production tests
  deploy-production:
    runs-on: ubuntu-latest
    needs: deploy-and-test-dev
    if: needs.deploy-and-test-dev.outputs.gating-status == 'success'
    environment: production
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3
        with:
          fetch-depth: 0
      
      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'
      
      - name: Install dependencies
        run: npm install --legacy-peer-deps
      
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1
      
      - name: Load Production environment configuration
        run: |
          source scripts/utilities/load-env-config.sh prod
          echo "PROD_INSTANCE_ID=$INSTANCE_ID" >> $GITHUB_ENV
          echo "PROD_TERMINAL_URL=$TERMINAL_URL" >> $GITHUB_ENV
          echo "PROD_S3_BUCKET=$S3_BUCKET" >> $GITHUB_ENV
          echo "PROD_S3_URL=$S3_URL" >> $GITHUB_ENV
          echo "PROD_DYNAMODB_STORIES_TABLE=$DYNAMODB_STORIES_TABLE" >> $GITHUB_ENV
          echo "PROD_DYNAMODB_TESTS_TABLE=$DYNAMODB_TESTS_TABLE" >> $GITHUB_ENV
          echo "PROD_TERMINAL_URL=$TERMINAL_URL" >> $GITHUB_ENV
          echo "PROD_S3_BUCKET=$S3_BUCKET" >> $GITHUB_ENV
          echo "PROD_S3_URL=$S3_URL" >> $GITHUB_ENV
          echo "PROD_DYNAMODB_STORIES_TABLE=$DYNAMODB_STORIES_TABLE" >> $GITHUB_ENV
          echo "PROD_DYNAMODB_TESTS_TABLE=$DYNAMODB_TESTS_TABLE" >> $GITHUB_ENV
      
      - name: Setup SSH key for deployment
        env:
          SSH_PRIVATE_KEY: ${{ secrets.EC2_SSH_PRIVATE_KEY }}
        run: |
          mkdir -p ~/.ssh
          if echo "$SSH_PRIVATE_KEY" | base64 -d > ~/.ssh/id_rsa 2>/dev/null; then
            echo "âœ… Decoded base64 SSH key"
          else
            echo "ðŸ“ Using raw SSH key"
            printf '%s' "$SSH_PRIVATE_KEY" > ~/.ssh/id_rsa
          fi
          sed -i 's/\r$//' ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keygen -l -f ~/.ssh/id_rsa >/dev/null 2>&1 && echo "âœ… SSH key configured" || (echo "âŒ SSH key validation failed" && exit 1)
      
      - name: Start Production EC2 if stopped
        run: |
          echo "ðŸ” Checking Production EC2 status..."
          
          EC2_STATE=$(aws ec2 describe-instances \
            --instance-ids ${{ env.PROD_INSTANCE_ID }} \
            --region us-east-1 \
            --query 'Reservations[0].Instances[0].State.Name' \
            --output text)
          
          echo "Current state: $EC2_STATE"
          
          if [ "$EC2_STATE" = "stopped" ]; then
            echo "âš ï¸  EC2 is stopped, starting instance..."
            aws ec2 start-instances --instance-ids ${{ env.PROD_INSTANCE_ID }} --region us-east-1
            
            echo "â³ Waiting for EC2 to start..."
            aws ec2 wait instance-running --instance-ids ${{ env.PROD_INSTANCE_ID }} --region us-east-1
            
            echo "â³ Waiting for services to be ready (60 seconds)..."
            sleep 60
          elif [ "$EC2_STATE" = "running" ]; then
            echo "âœ… Production EC2 is already running"
          else
            echo "âš ï¸  Production EC2 state: $EC2_STATE"
          fi
          
          # Get current IP from AWS after EC2 is running
          echo "ðŸ” Getting current prod EC2 IP from AWS..."
          CURRENT_IP=$(aws ec2 describe-instances \
            --instance-ids ${{ env.PROD_INSTANCE_ID }} \
            --region us-east-1 \
            --query 'Reservations[0].Instances[0].PublicIpAddress' \
            --output text)
          
          if [ -z "$CURRENT_IP" ] || [ "$CURRENT_IP" = "None" ]; then
            echo "âŒ Failed to get IP from AWS"
            exit 1
          fi
          
          echo "PROD_EC2_IP=$CURRENT_IP" >> $GITHUB_ENV
          echo "PROD_API_BASE=http://$CURRENT_IP:4000" >> $GITHUB_ENV
          echo "PROD_SEMANTIC_API_BASE=http://$CURRENT_IP:8083" >> $GITHUB_ENV
          echo "âœ… Current IP: $CURRENT_IP"
          
          # Wait for API to respond
          MAX_WAIT=60
          ELAPSED=0
          while [ $ELAPSED -lt $MAX_WAIT ]; do
            if curl -s --max-time 5 "http://$CURRENT_IP:4000/health" > /dev/null 2>&1; then
              echo "âœ… Production API is ready"
              break
            fi
            sleep 5
            ELAPSED=$((ELAPSED + 5))
          done
          
          if [ $ELAPSED -ge $MAX_WAIT ]; then
            echo "âš ï¸  API not responding after ${MAX_WAIT}s, proceeding anyway..."
          fi
          
          # Add SSH host key after EC2 is confirmed running (retry up to 30s)
          echo "ðŸ”‘ Adding SSH host key..."
          SSH_ADDED=false
          for i in 1 2 3 4 5 6; do
            if ssh-keyscan -H $CURRENT_IP >> ~/.ssh/known_hosts 2>/dev/null; then
              echo "âœ… SSH host key added"
              SSH_ADDED=true
              break
            fi
            echo "â³ Waiting for SSH to be ready... (attempt $i/6)"
            sleep 5
          done
          
          if [ "$SSH_ADDED" = "false" ]; then
            echo "âš ï¸  Could not add SSH host key, will try with StrictHostKeyChecking=no"
          fi
      
      - name: Deploy backend to Production EC2
        env:
          GITHUB_TOKEN: ${{ secrets.AIPM_GITHUB_TOKEN }}
        run: |
          echo "ðŸš€ Deploying backend to Production EC2..."
          
          ./scripts/deploy-simple.sh prod
          echo "âœ… Backend deployed to Production EC2"
      
      - name: Deploy Lambda functions to Production
        run: |
          echo "âš¡ Deploying Lambda functions to Production..."
          ./scripts/deploy-lambda.sh prod skip-errors || echo "âš ï¸  Lambda deployment skipped (functions not created yet)"
          echo "âœ… Lambda step complete"
      
      - name: Deploy frontend to Production S3
        run: |
          echo "ðŸ“¦ Deploying frontend to Production S3..."
          
          # Create production config
          cat > apps/frontend/public/config.js << EOF
          window.CONFIG = {
            API_BASE_URL: '${{ env.PROD_API_BASE }}',
            EC2_TERMINAL_URL: '${{ env.PROD_TERMINAL_URL }}',
            ENVIRONMENT: 'prod'
          };
          EOF
          
          aws s3 sync apps/frontend/public/ s3://${{ env.PROD_S3_BUCKET }} --delete --cache-control no-cache
          echo "âœ… Frontend deployed to Production S3"
      
      - name: Run Post-Production Gating Tests
        id: post_deployment
        env:
          GITHUB_TOKEN: ${{ secrets.AIPM_GITHUB_TOKEN }}
          TARGET_ENV: prod
          SKIP_GATING_TESTS_IN_CODE_GENERATION: true
        run: |
          echo "ðŸ” Running Post-Production Gating Tests on Production Environment"
          
          # Wait for deployment to be ready
          sleep 15
          
          # Reload environment config to get updated IP after deployment
          echo "ðŸ”„ Reloading production environment configuration..."
          source scripts/utilities/load-env-config.sh prod
          export API_BASE="$API_BASE"
          export SEMANTIC_API_BASE="$SEMANTIC_API_BASE"
          export SSH_HOST="$EC2_IP"
          
          echo "   Backend: $API_BASE (Production EC2)"
          echo "   Database: Development DynamoDB (via X-Use-Dev-Tables header)"
          export PHASE="post-production"
          
          # Test production environment health
          echo "Testing production environment..."
          
          # Frontend accessibility
          if curl -s "${{ env.PROD_S3_URL }}" | grep -q "AI Project Manager"; then
            echo "âœ… Production frontend accessible"
          else
            echo "âŒ Production frontend not accessible"
            exit 1
          fi
          
          # Backend API health
          if curl -s "$API_BASE/api/version" | grep -q "version"; then
            echo "âœ… Production backend healthy"
          else
            echo "âŒ Production backend not healthy"
            exit 1
          fi
          
          # Run gating tests with Production backend + Development DynamoDB
          if ./scripts/testing/run-structured-gating-tests.sh --phases "1,2"; then
            echo "âœ… Post-Production validation passed"
          else
            echo "âŒ Post-Production validation failed"
            exit 1
          fi
      
      - name: Sync Production to Development
        if: success()
        run: |
          echo "ðŸ”„ Syncing Production data to Development..."
          node scripts/utilities/sync-prod-to-dev.cjs
          echo "âœ… Sync completed"
      
      - name: Create deployment summary
        if: always()
        run: |
          echo "## ðŸš€ Production Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Status**: ${{ steps.post_deployment.outcome == 'success' && 'âœ… Success' || 'âŒ Failed' }}" >> $GITHUB_STEP_SUMMARY
          echo "**Commit**: ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
          echo "**Triggered by**: ${{ github.event_name }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Environment URLs:**" >> $GITHUB_STEP_SUMMARY
          echo "- ðŸ”— Frontend: http://aipm-static-hosting-demo.s3-website-us-east-1.amazonaws.com" >> $GITHUB_STEP_SUMMARY
          echo "- ðŸ”— Backend API: http://100.53.112.192:4000" >> $GITHUB_STEP_SUMMARY
          echo "- ðŸ”— Semantic API: http://100.53.112.192:8083" >> $GITHUB_STEP_SUMMARY
