import { DynamoDBClient } from '@aws-sdk/client-dynamodb';
import { DynamoDBDocumentClient, PutCommand, QueryCommand } from '@aws-sdk/lib-dynamodb';

const dynamoClient = new DynamoDBClient({ region: process.env.AWS_REGION });
const docClient = DynamoDBDocumentClient.from(dynamoClient);

const TASK_QUEUE_TABLE = process.env.TASK_QUEUE_TABLE;

export const handler = async (event) => {
  const headers = {
    'Access-Control-Allow-Origin': '*',
    'Access-Control-Allow-Methods': 'GET, POST, OPTIONS',
    'Access-Control-Allow-Headers': 'Content-Type',
    'Content-Type': 'application/json'
  };

  // Handle CORS preflight
  if (event.httpMethod === 'OPTIONS') {
    return { statusCode: 200, headers, body: '' };
  }

  const path = event.path;
  const method = event.httpMethod;

  try {
    // Health check
    if (path === '/health' && method === 'GET') {
      return {
        statusCode: 200,
        headers,
        body: JSON.stringify({
          status: 'running',
          service: 'kiro-api-lambda',
          environment: process.env.ENVIRONMENT,
          timestamp: new Date().toISOString()
        })
      };
    }

    // Kiro API endpoints
    if (path.startsWith('/kiro/') && method === 'POST') {
      const endpoint = path.split('/')[2];
      const body = JSON.parse(event.body || '{}');
      
      // Create task in queue
      const taskId = `${endpoint}-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
      const task = {
        taskId,
        endpoint,
        payload: body,
        status: 'pending',
        createdAt: Date.now(),
        updatedAt: Date.now()
      };

      await docClient.send(new PutCommand({
        TableName: TASK_QUEUE_TABLE,
        Item: task
      }));

      // For now, return a mock response since we don't have Kiro CLI in Lambda
      const mockResponse = generateMockResponse(endpoint, body);
      
      return {
        statusCode: 200,
        headers,
        body: JSON.stringify(mockResponse)
      };
    }

    // Default 404
    return {
      statusCode: 404,
      headers,
      body: JSON.stringify({ error: 'Not found' })
    };

  } catch (error) {
    console.error('Lambda error:', error);
    return {
      statusCode: 500,
      headers,
      body: JSON.stringify({ error: error.message })
    };
  }
};

function generateMockResponse(endpoint, payload) {
  switch (endpoint) {
    case 'chat':
      return {
        message: `Mock response for: ${payload.message || payload.prompt || 'Hello'}`,
        success: true,
        source: 'lambda-mock'
      };
    
    case 'generate-code':
      return {
        generated: true,
        code: `// Mock generated code for: ${payload.prompt}\nfunction mockFunction() {\n  return 'Generated by Kiro API Lambda';\n}`,
        source: 'lambda-mock'
      };
    
    case 'enhance-story':
      return {
        title: payload.draft?.title || 'Enhanced Story Title',
        description: 'Enhanced story description',
        enhanced: true,
        source: 'lambda-mock'
      };
    
    case 'generate-acceptance-test':
      return {
        title: `Acceptance Test ${payload.ordinal || 1}`,
        given: ['System is ready', 'User has permissions'],
        when: ['User performs action'],
        then: ['Expected outcome occurs'],
        generated: true,
        source: 'lambda-mock'
      };
    
    case 'analyze-invest':
      return {
        score: 75,
        summary: 'Mock INVEST analysis',
        analyzed: true,
        source: 'lambda-mock'
      };
    
    default:
      return {
        success: true,
        message: `Mock response for ${endpoint}`,
        source: 'lambda-mock'
      };
  }
}
