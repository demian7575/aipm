#!/bin/bash
# Generate Phase 4 tests from acceptance tests in DynamoDB
# Usage: ./generate-phase4-from-acceptance-tests.sh [prod|dev]

set -e

TEST_GEN_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
source "$TEST_GEN_DIR/../utilities/load-env-config.sh" "${1:-prod}"

OUTPUT_FILE="$TEST_GEN_DIR/phase4-generated.sh"
TEMP_FILE="/tmp/phase4-generated-$$.sh"

echo "ðŸ”§ Generating Phase 4 tests from acceptance tests..."
echo "Environment: ${1:-prod}"
echo "Table: $DYNAMODB_TESTS_TABLE"

# Fetch all acceptance tests from DynamoDB
echo "ðŸ“¥ Fetching acceptance tests from DynamoDB..."
TESTS=$(aws dynamodb scan \
  --table-name "$DYNAMODB_TESTS_TABLE" \
  --region us-east-1 \
  --output json)

TEST_COUNT=$(echo "$TESTS" | jq '.Items | length')
echo "âœ… Found $TEST_COUNT acceptance tests"

# Generate test script header
cat > "$TEMP_FILE" << 'EOF'
#!/bin/bash
# Auto-generated Phase 4 tests from acceptance tests
# DO NOT EDIT MANUALLY - Generated by generate-phase4-from-acceptance-tests.sh

set -e

TEST_SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
source "$TEST_SCRIPT_DIR/../utilities/load-env-config.sh" "${TARGET_ENV:-prod}"
source "$TEST_SCRIPT_DIR/test-library.sh"

PASSED=0
FAILED=0
SKIPPED=0
PHASE="phase4-generated"

echo "ðŸ§ª Phase 4: Generated Tests from Acceptance Tests"
echo "=================================================="
echo "Run ID: $TEST_RUN_ID"
echo ""

EOF

# Generate test functions
echo "ðŸ”¨ Generating test functions..."

echo "$TESTS" | jq -c '.Items[]' | while read -r test; do
  TEST_ID=$(echo "$test" | jq -r '.id.N')
  STORY_ID=$(echo "$test" | jq -r '.storyId.N')
  TITLE=$(echo "$test" | jq -r '.title.S')
  
  # Extract when clause (test action)
  WHEN=$(echo "$test" | jq -r '.when.L[0].S // empty')
  
  # Skip if no when clause
  if [ -z "$WHEN" ] || [ "$WHEN" == "null" ]; then
    continue
  fi
  
  # Pattern 1: "I METHOD /endpoint" or "METHOD /endpoint"
  if [[ "$WHEN" =~ (GET|POST|PUT|DELETE|PATCH)[[:space:]]+(/[^[:space:]]*) ]]; then
    METHOD="${BASH_REMATCH[1]}"
    ENDPOINT="${BASH_REMATCH[2]}"
    
    cat >> "$TEMP_FILE" << TESTEOF

# Test $TEST_ID: $TITLE (Story #$STORY_ID)
echo "Test $TEST_ID: $TITLE"
START_TIME=\$(date +%s)
RESPONSE=\$(curl -s -X $METHOD "\$API_BASE$ENDPOINT" -H "Content-Type: application/json" 2>&1)
DURATION=\$(((\$(date +%s) - START_TIME)))
if echo "\$RESPONSE" | grep -qE '(^\[|^\{|"id"|"status")'; then
  echo "  âœ… PASS: $TITLE"
  PASSED=\$((PASSED + 1))
  record_test_result "$TEST_ID" "$TITLE" "PASS" "\$PHASE" "\$DURATION"
else
  echo "  âŒ FAIL: $TITLE"
  FAILED=\$((FAILED + 1))
  record_test_result "$TEST_ID" "$TITLE" "FAIL" "\$PHASE" "\$DURATION"
fi

TESTEOF
  
  # Pattern 2: Function calls like "getStories() is called"
  elif [[ "$WHEN" =~ (get|create|update|delete|list)([A-Z][a-zA-Z]+)\(\) ]]; then
    ACTION="${BASH_REMATCH[1]}"
    RESOURCE="${BASH_REMATCH[2]}"
    
    # Map to API endpoints
    case "$ACTION" in
      get|list) METHOD="GET" ;;
      create) METHOD="POST" ;;
      update) METHOD="PUT" ;;
      delete) METHOD="DELETE" ;;
      *) continue ;;
    esac
    
    # Convert resource name to endpoint
    ENDPOINT=$(echo "$RESOURCE" | sed 's/\([A-Z]\)/-\L\1/g' | sed 's/^-//')
    
    cat >> "$TEMP_FILE" << TESTEOF

# Test $TEST_ID: $TITLE (Story #$STORY_ID)
echo "Test $TEST_ID: $TITLE"
START_TIME=\$(date +%s)
RESPONSE=\$(curl -s -X $METHOD "\$API_BASE/api/$ENDPOINT" -H "Content-Type: application/json" 2>&1)
DURATION=\$(((\$(date +%s) - START_TIME)))
if echo "\$RESPONSE" | grep -qE '(^\[|^\{|"id"|"status")'; then
  echo "  âœ… PASS: $TITLE"
  PASSED=\$((PASSED + 1))
  record_test_result "$TEST_ID" "$TITLE" "PASS" "\$PHASE" "\$DURATION"
else
  echo "  âŒ FAIL: $TITLE"
  FAILED=\$((FAILED + 1))
  record_test_result "$TEST_ID" "$TITLE" "FAIL" "\$PHASE" "\$DURATION"
fi

TESTEOF
  
  # Pattern 3: UI interactions - mark as SKIP
  elif [[ "$WHEN" =~ (click|select|enter|type|press|appears|shown) ]]; then
    cat >> "$TEMP_FILE" << TESTEOF

# Test $TEST_ID: $TITLE (Story #$STORY_ID) - UI Test
echo "Test $TEST_ID: $TITLE"
echo "  âš ï¸  SKIP: UI test (requires browser automation)"
SKIPPED=\$((SKIPPED + 1))
record_test_result "$TEST_ID" "$TITLE" "SKIP" "\$PHASE" "0"

TESTEOF
  
  # Pattern 4: Everything else - try to infer from title
  else
    # Check if title suggests an API endpoint
    if [[ "$TITLE" =~ (GET|POST|PUT|DELETE|PATCH) ]]; then
      # Extract method from title
      METHOD=$(echo "$TITLE" | grep -oE '(GET|POST|PUT|DELETE|PATCH)' | head -1)
      
      # Try to extract endpoint from title or when clause
      if [[ "$TITLE" =~ /api/[a-z/-]+ ]]; then
        ENDPOINT="${BASH_REMATCH[0]}"
      elif [[ "$WHEN" =~ /api/[a-z/-]+ ]]; then
        ENDPOINT="${BASH_REMATCH[0]}"
      else
        # Skip if can't determine endpoint
        continue
      fi
      
      cat >> "$TEMP_FILE" << TESTEOF

# Test $TEST_ID: $TITLE (Story #$STORY_ID)
echo "Test $TEST_ID: $TITLE"
START_TIME=\$(date +%s)
RESPONSE=\$(curl -s -X $METHOD "\$API_BASE$ENDPOINT" -H "Content-Type: application/json" 2>&1)
DURATION=\$(((\$(date +%s) - START_TIME)))
if echo "\$RESPONSE" | grep -qE '(^\[|^\{|"id"|"status")'; then
  echo "  âœ… PASS: $TITLE"
  PASSED=\$((PASSED + 1))
  record_test_result "$TEST_ID" "$TITLE" "PASS" "\$PHASE" "\$DURATION"
else
  echo "  âŒ FAIL: $TITLE"
  FAILED=\$((FAILED + 1))
  record_test_result "$TEST_ID" "$TITLE" "FAIL" "\$PHASE" "\$DURATION"
fi

TESTEOF
    fi
  fi
done

# Generate test script footer
cat >> "$TEMP_FILE" << 'EOF'

echo ""
echo "=================================================="
echo "Test Results:"
echo "  Passed: $PASSED"
echo "  Failed: $FAILED"
echo "  Skipped: $SKIPPED"
echo "  Total: $((PASSED + FAILED + SKIPPED))"
echo "=================================================="

if [ $FAILED -gt 0 ]; then
  exit 1
fi

exit 0
EOF

# Make executable and move to final location
chmod +x "$TEMP_FILE"
mv "$TEMP_FILE" "$OUTPUT_FILE"

echo "âœ… Generated test script: $OUTPUT_FILE"
echo "ðŸ“Š Generated tests: $(grep -c "^# Test" "$OUTPUT_FILE" || echo 0)"
echo ""
echo "To run: $OUTPUT_FILE"
