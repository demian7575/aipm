# Code Generation Flow (Option 1)

## Overview
Direct synchronous API call from Backend to EC2 for code generation.

## Architecture

```
┌──────────────┐
│   Browser    │
│     User     │
└──────┬───────┘
       │ Click "Generate Code & PR"
       ↓
┌──────────────┐
│   Backend    │
│   (Lambda)   │
└──────┬───────┘
       │
       ├─→ 1. Create GitHub PR + branch
       │
       └─→ 2. POST http://3.92.96.67:8080/generate-code
                {
                  "branch": "feature/xyz-123",
                  "taskDescription": "Add login validation",
                  "prNumber": 42
                }
                ↓
           ┌────────────────┐
           │  EC2 Server    │
           │  (Port 8080)   │
           └────────┬───────┘
                    │
                    ├─→ git checkout <branch>
                    ├─→ kiro-cli chat "<task>"
                    ├─→ git commit && push
                    │
                    └─→ Returns: { success: true, branch }
                         ↓
                    ┌────────────┐
                    │ GitHub PR  │
                    │ (Updated)  │
                    └────────────┘
```

## Flow Steps

### 1. User Action
```javascript
// User clicks "Generate Code & PR" button
// Fills form with:
{
  taskTitle: "Add user authentication",
  objective: "Implement JWT-based login",
  constraints: "Use bcrypt, 15min token expiry",
  acceptanceCriteria: [
    "POST /api/login endpoint",
    "Returns JWT token",
    "Validates email/password"
  ]
}
```

### 2. Backend Creates PR
```javascript
// apps/backend/app.js - performDelegation()

// Create branch from main
const branchName = `feature/${taskTitle}-${timestamp}`;
await githubRequest('/repos/.../git/refs', {
  method: 'POST',
  body: { ref: `refs/heads/${branchName}`, sha: mainSha }
});

// Create PR
const pr = await githubRequest('/repos/.../pulls', {
  method: 'POST',
  body: {
    title: taskTitle,
    head: branchName,
    base: 'main',
    body: '⏳ Code is being generated by Kiro CLI...'
  }
});
```

### 3. Backend Calls EC2
```javascript
// Direct HTTP call to EC2
const response = await fetch('http://3.92.96.67:8080/generate-code', {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify({
    branch: branchName,
    taskDescription: `${objective}. Constraints: ${constraints}. Criteria: ${criteria}`,
    prNumber: pr.number
  })
});

const result = await response.json();
// { success: true, message: "Code generated successfully", branch }
```

### 4. EC2 Generates Code
```javascript
// scripts/workers/terminal-server.js

// Checkout branch
execSync(`cd ${REPO_PATH} && git fetch origin && git checkout ${branch}`);

// Send to Kiro CLI (persistent session)
kiro.write(`${taskDescription}\n`);

// Wait 30 seconds for generation
await new Promise(resolve => setTimeout(resolve, 30000));

// Commit and push
execSync(`cd ${REPO_PATH} && git add . && git commit -m "feat: ${taskDescription}" && git push origin ${branch}`);
```

### 5. Result
- PR updated with generated code
- User sees updated PR in GitHub
- Developer reviews and merges

## API Endpoints

### POST /generate-code

**Request:**
```json
{
  "branch": "feature/add-login-1764574560626",
  "taskDescription": "Implement JWT login. Constraints: bcrypt, 15min expiry. Criteria: POST /api/login, returns JWT, validates credentials",
  "prNumber": 42
}
```

**Response (Success):**
```json
{
  "success": true,
  "message": "Code generated successfully",
  "branch": "feature/add-login-1764574560626"
}
```

**Response (No Changes):**
```json
{
  "success": true,
  "message": "No changes needed",
  "branch": "feature/add-login-1764574560626"
}
```

**Response (Error):**
```json
{
  "success": false,
  "error": "Command failed: git push origin..."
}
```

## Configuration

### Backend Environment Variables
```bash
EC2_TERMINAL_URL=http://3.92.96.67:8080  # EC2 server URL
```

### EC2 Environment Variables
```bash
PORT=8080                          # HTTP server port
REPO_PATH=/home/ec2-user/aipm     # Git repository path
```

## Timing

| Step | Duration |
|------|----------|
| Create PR | ~2 seconds |
| Call EC2 | ~1 second |
| Kiro generates code | ~30 seconds |
| Commit & push | ~2 seconds |
| **Total** | **~35 seconds** |

## Error Handling

### Backend Errors
- If EC2 call fails, PR is still created
- User can manually refine with "Refine with Kiro" button
- Error logged but doesn't block PR creation

### EC2 Errors
- Git checkout fails → Returns error
- Kiro generates nothing → Returns "No changes needed"
- Git push fails → Returns error with details

## Comparison with Queue-Based Approach

| Aspect | Option 1 (Direct API) | Queue-Based |
|--------|----------------------|-------------|
| **Complexity** | Simple | Complex |
| **Speed** | Immediate | 5s delay + processing |
| **Dependencies** | Backend + EC2 | Backend + DynamoDB + EC2 |
| **Debugging** | Easy (direct logs) | Hard (queue status) |
| **Failure handling** | Immediate response | Status polling needed |
| **Infrastructure** | 2 components | 3 components |

## Monitoring

### Check EC2 Server Status
```bash
ssh ec2-user@3.92.96.67 "ps aux | grep terminal-server"
```

### View EC2 Logs
```bash
ssh ec2-user@3.92.96.67 "tail -f terminal-server.log"
```

### Test Endpoint
```bash
curl -X POST http://3.92.96.67:8080/generate-code \
  -H "Content-Type: application/json" \
  -d '{"branch":"test-branch","taskDescription":"Add test","prNumber":1}'
```

### Restart Server
```bash
cd /repo/ebaejun/tools/aws/aipm
./scripts/workers/start-kiro-terminal.sh
```

## Security

- ✅ EC2 has SSH key authentication
- ✅ Code generated in separate branches
- ✅ Human review required before merge
- ⚠️ HTTP endpoint (not HTTPS) - EC2 IP only
- ❌ Never auto-merge generated code

## Future Improvements

1. **Add HTTPS** - Use nginx reverse proxy with SSL
2. **Add authentication** - API key or JWT token
3. **Streaming response** - WebSocket for real-time progress
4. **Better timeout** - Detect when Kiro finishes (not fixed 30s)
5. **Retry logic** - Auto-retry on transient failures
